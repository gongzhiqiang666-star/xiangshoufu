# 享收付实施方案（单机版 + 升级预留）

## 设计原则

> **当前单机优先，预留升级空间**
> - 第一阶段：单机部署，简单可靠
> - 第二阶段：业务增长后，平滑升级到分布式架构

---

## 一、核心问题解答

### 1. 原始交易数据保留策略

| 项目 | 当前方案（单机） | 升级方案 |
|------|------------------|----------|
| **保留位置** | PostgreSQL 分区表 | 不变 |
| **热数据** | 90天在线查询 | 不变 |
| **冷数据** | 本地归档目录 | → OSS云存储 |
| **清理策略** | 定时任务自动清理 | 不变 |

### 2. 服务器压力与性能保障（单机版）

**预估负载：**
| 指标 | 初期预估 | 单机可承受 |
|------|----------|------------|
| 日均回调量 | 10-50万次 | ✅ 轻松应对 |
| 峰值QPS | 100-500/s | ✅ Go单机可达5000+/s |
| 日增存储 | 200MB-1GB | ✅ 500GB SSD足够 |

**单机性能保障措施：**
- **Goroutine池**：替代Kafka，使用Go协程池异步处理（后续可替换为Kafka）
- **本地缓存**：使用 go-cache 做幂等检查（后续可替换为Redis）
- **批量写入**：100条一批入库，减少数据库压力
- **限流中间件**：单机限流，防止突发流量


### 2.3 签名验证

- **算法**：RSA + SHA256
- **流程**：移除sign字段 → 字典序排列 → key1=value1&key2=value2 → RSA验签

---

## 四、数据处理流程

### 4.1 整体流程（异步处理 + 定时兜底）

采用**混合方案**：异步Goroutine准实时计算 + 定时任务兜底重试

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           第一阶段：快速响应（同步，<50ms）                 │
├──────────────────────────────────────────────────────────────────────────┤
│   通道回调 → 验签 → 落库(原始数据表，待处理) → 返回 {"code":0}              │
└────────────────────────────────┬─────────────────────────────────────────┘
                                 ↓
                           放入内存队列
                                 ↓
┌──────────────────────────────────────────────────────────────────────────┐
│                           第二阶段：数据解析（异步，秒级）                   │
├──────────────────────────────────────────────────────────────────────────┤
│   Goroutine消费 → 解析原始数据 → 写入业务表                                 │
│                               │                                          │
│              ┌────────────────┴────────────────┐                         │
│              ↓                                 ↓                         │
│        交易(pos_order)                   其他(商户/终端等)                 │
│              ↓                                 ↓                         │
│        写入交易表                          直接入库                        │
│              ↓                                                           │
│   更新原始数据: process_status = 1 (已处理)                                │
└────────────────────────────────┬─────────────────────────────────────────┘
                                 ↓
                           放入分润队列
                                 ↓
┌──────────────────────────────────────────────────────────────────────────┐
│                           第三阶段：分润计算（异步，秒级）                   │
├──────────────────────────────────────────────────────────────────────────┤
│   Goroutine池消费(并发10) → 计算分润 → 更新钱包                             │
│                               ↓                                          │
│       1. 查找商户 → 获取直属代理商                                         │
│       2. 沿代理商树向上遍历 (parent_id)                                    │
│       3. 每一级计算费率差分润                                              │
│       4. 写入分润记录 (profit_records)                                     │
│       5. 更新钱包余额 (wallet) + 记录流水                                  │
│       6. 检查激活奖励条件                                                  │
│       7. 触发消息通知 (站内消息 + APP推送)                                  │
│                               ↓                                          │
│   成功: 更新交易 profit_status = 1 (已计算)                                │
│   失败: 保持 profit_status = 0，等待定时任务重试                            │
└──────────────────────────────────────────────────────────────────────────┘
                                 ↓
                          失败兜底（5分钟定时任务）
                                 ↓
┌──────────────────────────────────────────────────────────────────────────┐
│                           第四阶段：兜底重试（定时，5分钟）                  │
├──────────────────────────────────────────────────────────────────────────┤
│   定时任务(每5分钟) → 查询 profit_status=0 且 created_at > 5分钟前的交易    │
│                    → 重新计算分润                                         │
│                    → 告警(如果同一笔交易多次失败)                           │
└──────────────────────────────────────────────────────────────────────────┘
```

### 4.2 混合方案优势

| 优势 | 说明 |
|------|------|
| **准实时** | 正常情况下秒级完成分润计算 |
| **快速响应** | 回调<50ms返回，不阻塞 |
| **并发可控** | Goroutine池限制并发数=10 |
| **自动重试** | 失败的由定时任务兜底 |
| **可观测** | 通过profit_status监控积压情况 |

### 4.3 消息通知设计

分润入账后需要通知代理商，设计如下：

```
分润计算完成 → 更新钱包余额 → 触发消息通知
                              ↓
                    ┌─────────┴─────────┐
                    ↓                   ↓
              站内消息(message表)    推送通知(可选)
                    ↓                   ↓
              APP消息中心显示      极光/个推推送到APP
```

**消息类型：**
| 类型 | 触发条件 | 消息内容示例 |
|------|---------|-------------|
| 交易分润 | 每笔交易分润入账 | "您获得交易分润 ¥1.25" |
| 激活奖励 | 达标激活奖励发放 | "恭喜！商户xxx激活奖励 ¥50 已到账" |
| 押金返现 | 押金扣费成功 | "押金返现 ¥10 已到账" |
| 流量返现 | 流量费扣费成功 | "流量费返现 ¥5 已到账" |
| 退款撤销 | 退款导致分润撤销 | "交易xxx已退款，分润 ¥1.25 已扣回" |

---

## 五、单机版技术架构

### 5.1 整体架构图

```
                    8个支付通道回调
                          │
                          ▼
               ┌─────────────────────┐
               │    Nginx (限流)      │
               └──────────┬──────────┘
                          │
                          ▼
               ┌─────────────────────┐
               │  Gin HTTP Server    │  ← 单机部署
               │  (统一回调入口)       │
               └──────────┬──────────┘
                          │
          ┌───────────────┼───────────────┐
          ▼               ▼               ▼
    ┌──────────┐   ┌──────────────┐  ┌──────────┐
    │ 适配器    │   │ Goroutine池  │  │ 本地缓存  │
    │ 工厂      │   │ (异步处理)   │  │ (幂等)   │
    └──────────┘   └──────┬───────┘  └──────────┘
                          │
                          ▼
               ┌─────────────────────┐
               │   PostgreSQL        │  ← 单机数据库
               │   (分区表存储)       │
               └─────────────────────┘
```

### 5.3 升级预留设计

```go
// 队列接口 - 当前用内存队列，后续可无缝切换到Kafka
type MessageQueue interface {
    Publish(topic string, msg []byte) error
    Subscribe(topic string, handler func([]byte) error) error
}

// 缓存接口 - 当前用本地缓存，后续可无缝切换到Redis
type Cache interface {
    Get(key string) (interface{}, bool)
    Set(key string, value interface{}, ttl time.Duration)
    Exists(key string) bool
}
```

---

## 六、实施计划（单机版简化）

| 阶段 | 内容 | 工期 |
|------|------|------|
| **第1周** | 基础架构 | 5天 |
| | - 原始数据表 + 分区策略 | |
| | - 适配器框架 + 工厂模式 | |
| | - 异步队列接口 + 内存实现 | |
| **第2周** | 恒信通对接 | 5天 |
| | - 5种回调完整实现 | |
| | - 签名验证 + 数据映射 | |
| | - 单元测试 + 联调测试 | |
| **第3-4周** | 其他7通道 | 10天 |
| | - 复用适配器模板快速开发 | |
| **第5周** | 测试上线 | 5天 |
| | - 功能测试 + 压力测试 | |
| | - 部署上线 | |

---

## 七、验证方案

### 7.1 功能验证

1. **恒信通回调测试**
   - 使用Postman模拟5种回调请求
   - 验证签名验证、数据映射、入库正确性

2. **幂等性测试**
   - 重复发送相同回调，验证不重复处理

3. **数据一致性**
   - 对比原始数据与映射后数据

### 7.2 性能验证（单机目标）

| 指标 | 目标值 |
|------|--------|
| 单机QPS | > 1000/s |
| 接口响应时间 | < 50ms (P99) |
| 数据库写入延迟 | < 100ms |
| 错误率 | < 0.1% |

---

## 八、升级路径（业务增长后）

| 当前（单机） | 升级后（分布式） | 触发条件 |
|-------------|-----------------|----------|
| Goroutine池 | → Kafka集群 | QPS > 2000 |
| 本地缓存 | → Redis集群 | 需要多实例部署 |
| 单机PostgreSQL | → 主从复制 | 写入QPS > 500 |
| 单机部署 | → K8s多副本 | 高可用需求 |
| 本地归档 | → OSS云存储 | 存储 > 500GB |

**升级成本**：仅需替换接口实现，业务代码无需修改

### 9.2 轻量级监控方案

采用**Go内置 + 企业微信/钉钉告警**方案：

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  应用内置指标    │ →  │   定时检查任务   │ →  │  企业微信告警    │
│  (expvar/内存)  │     │   (每分钟)       │     │  (Webhook)      │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

**监控指标（内存统计）：**
| 指标 | 告警阈值 | 说明 |
|------|---------|------|
| 各通道回调成功率 | < 95% | 5分钟窗口 |
| 待处理数据积压 | > 500条 | 内存队列长度 |
| 接口响应时间 | P99 > 500ms | |
| 签名验证失败 | > 10次/分钟 | 可能遭受攻击 |

### 9.3 安全措施

| 措施 | 实现 |
|------|------|
| IP白名单 | Nginx `allow/deny` 配置 |
| 敏感数据加密 | AES-256-GCM 加密存储 |
| 签名失败处理 | 记录+告警，返回成功（防止通道重试） |
